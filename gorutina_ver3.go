// Анатомия каналов в Go (https://habr.com/ru/post/490336/)
package main

import (
	"fmt"
	"runtime"
)

func main() {
	// Что такое каналы?
	// Канал — это объект связи, с помощью которого горутины обмениваются данными.
	// Создание канала
	// Программа создает канал c, который будет передавать int. Данная программа выведет <nil>, потому что нулевое значение канала — это nil.
	var c chan int
	fmt.Println(c)
	// Для инициализации канала необходимо использовать make.
	c = make(chan int)
	fmt.Printf("%T\n", c) // выводит: chan int
	fmt.Printf("%v\n", c) // выводит: 0xc000082120 - В go каналы являются указателями.

	fmt.Println("-------------------------------------------------------------------------------")
	// Запись и чтение данных
	// var data int
	// c <- data  // мы передаем данные в канал c.
	// <-c // мы считываем данные с канала c. Эта операция не сохраняет данные в переменную и она является корректной.
	// data = <-c // Если необходимо сохранить данные с канала в переменную. Короткая запись: data := <- c
	// Внимание!
	// Все вышеобозначенные операции с каналом являются блокируемыми.
	// Когда вы помещаете данные в канал, горутина блокируется до тех пор, пока данные не будут считаны другой горутиной из этого канала.
	// В то же время операции канала говорят планировщику о планировании другой горутины, поэтому программа не будет заблокирована полностью.

	fmt.Println("-------------------------------------------------------------------------------")
	// Каналы на практике
	fmt.Println("main() started") // В функции main программа сначала выводит "main() started".
	c1 := make(chan string)       // Затем мы, используя make, создаем канал c с типом даных string.
	go greet(c1)                  // Помещаем канал с в функцию greet и запускаем функцию как горутину, используя ключевое слово go.
	// Теперь у нас имеется две горутины main и greet, main по-прежнему остается активной.
	c1 <- "John" // Помещаем данные в канал с и в этот момент main блокируется до тех пор, пока другая горутина (greet) не считает данные из канала c.
	// Планировщик Go планирует запуск greet и выполняет описанные в ней действия.
	fmt.Println("main() stopped") // После чего main снова становится активной и выводит в консоль "main() stopped".

	fmt.Println("-------------------------------------------------------------------------------")
	// Deadlock (Взаимная блокировка)
	// Примером deadlock может быть main горутина, которая эксклюзивно производит операции с каналом.
	// c1 = make(chan string)
	// c1 <- "John"

	fmt.Println("-------------------------------------------------------------------------------")
	// Закрытие канала
	// В Go так же можно закрыть канал. Через закрытый канал невозможно будет передать или принять данные.
	// Горутина может проверить закрыт канал или нет, используя следующую конструкцию:
	// val, ok := <- channel	// где ok будет истиной в случае, если канал открыт или операция чтения может быть выполнена.
	//  Закрыть канал можно, используя встроенную функцию close, используя следующий синтаксис:
	// close(channel)
	// Пример с циклом for
	// В этом примере мы создаем горутину squares, которая последовательно возвращает квадраты чисел от 0 до 9. В main мы считываем эти числа внутри цикла for.
	c = make(chan int)
	go squares(c) // запускаем горутину
	for {         // Бесконечный цикл может быть полезен для чтения данных из канала, когда мы не знаем сколько данных мы ожидаем.
		val, ok := <-c
		if ok == false {
			fmt.Println(val, ok, "<-- loop broke!") // "разрыв петли"
			break                                   // ??? "перерыв"
		} else {
			fmt.Println(val, ok)
		}
	}
	fmt.Println("main() stopped")
	// Внимание! Когда канал закрыт, значение val, считанное горутиной, является нулевым значением, в зависимости от типа данных канала. Так как в нашем случае тип данных канала int, то нулевое значение будет 0, как раз это мы и видим в этой строке: 0 false <-- loop broke!
	fmt.Println("-------------------------------------------------------------------------------")
	// Для того, чтобы избежать столь громоздкой проверки закрытия канала в случае цикла for, Go предоставляет ключевое слово range, которое автоматически останавливает цикл, когда канал будет закрыт. Давайте перепишем нашу программу с использованием range:
	c = make(chan int) // повторно инициализирую канал, чтобы он открылся
	go squares(c)
	for val := range c { // range будет считывать данные из канала до тех пор, пока канал не будет закрыт.
		fmt.Println(val)
	}
	fmt.Println("main() stopped")

	fmt.Println("-------------------------------------------------------------------------------")
	// Размер буфера канала
	// Для объявления буферизированного канала мы можем использовать следующий синтаксис:
	// c := make(chan Type, n)
	// Это выражение создаст канал с типом данных Type и размером буфера n. Текущая горутина не будет заблокирована, пока в канал не будет передано n+1 данных.
	// Давайте докажем, что горутина не блокируется, пока буфер не заполнится и не переполнится:
	fmt.Println("main() started")
	c = make(chan int, 3) // канал может содержать 3 значения(c <- 3)
	go squares1(c)
	c <- 1
	c <- 2
	c <- 3
	c <- 4 // помещаем дополнительное значение в буфер и main блокируется, затем стартует горутина squares, которая вычитывает все значения из буфера, пока он не станет пустым.
	c <- 5
	fmt.Println("main() stopped")

	fmt.Println("-------------------------------------------------------------------------------")
	// Длина и емкость канала
	// Подобно срезам, буферизированный канал имеет длину и емкость.
	// Длина канала — это количество значений в очереди (не считанных) в буфере канала, емкость — это размер самого буфера канала.
	// Для того, чтобы вычислить длину, мы используем функцию len, а, используя функцию cap, получаем размер буфера.
	fmt.Printf("Length of channel c is %v and capacity of channel c is %v\n", len(c), cap(c))
	go sender(c)
	fmt.Printf("Length of channel c is %v and capacity of channel c is %v\n", len(c), cap(c))
	// read values from c (blocked here) - чтение данных из канала с (блокирует здесь)
	for val := range c {
		fmt.Printf("Length of channel c after value '%v' read is %v\n", val, len(c))
	}
	fmt.Println("-------------------------------------------------------------------------------")
	// Дополнительный пример с буферизированным каналом:
	c2 := make(chan int, 3)
	fmt.Println("main() started")
	go squares2(c2)
	fmt.Println("active goroutines", runtime.NumGoroutine()) // "NumGoroutine возвращает количество существующих на данный момент горутин"
	c2 <- 1
	c2 <- 2
	c2 <- 3
	c2 <- 4 // blocks here
	fmt.Println("active goroutines", runtime.NumGoroutine())
	go squares2(c2)
	fmt.Println("active goroutines", runtime.NumGoroutine())
	c2 <- 5
	c2 <- 6
	c2 <- 7
	c2 <- 8 // blocks here
	fmt.Println("active goroutines", runtime.NumGoroutine())
	fmt.Println("main() stopped")
	fmt.Println("-------------------------------------------------------------------------------")
	// Используя буферизованный канал и цикл for range, мы можем читать с закрытых каналов. Поскольку у закрытых каналов данные все еще живут в буфере, их можно считать:
	c3 := make(chan int, 3) // c3 является закрытым каналом, т.к. значения из канала никуда не приходят.
	c3 <- 1
	c3 <- 2
	c3 <- 3
	close(c3)
	// iteration terminates after receiving 3 values
	for elem := range c3 {
		fmt.Println(elem)
	}

	fmt.Println("-------------------------------------------------------------------------------")
	// Работа с несколькими горутинами
	// Давайте напишем 2 горутины, одна для вычисления квадрата целого числа, а другая для вычисления куба:
	fmt.Println("[main] main() started")
	squareChan := make(chan int) // инициализация небуферизированного канала
	cubeChan := make(chan int)   // инициализация небуферизированного канала
	testNum := 3
	fmt.Println("[main] sent testNum to squareChan")
	squareChan <- testNum
	fmt.Println("[main] resuming") // "[main] возобновляется"
	fmt.Println("[main] sent testNum to cubeChan")
	cubeChan <- testNum
	fmt.Println("[main] main() resuming")
	fmt.Println("[main] reading from channels")
	squareVal, cubeVal := <-squareChan, <-cubeChan
	sum := squareVal + cubeVal
	fmt.Println("[main] sum of square and cube of ", testNum, " is ", sum)
	fmt.Println("[main] main() stopped")
}
func greet(c chan string) { // Мы объявили функцию greet, которая принимает канал c как аргумент.
	fmt.Println("Hello " + <-c + "!") // В этой функции мы считываем данные из канала c и выводим в консоль.
}
func squares(c chan int) {
	for i := 0; i <= 9; i++ {
		c <- i * i // передача данных в канал
	}
	close(c) // закрытие канала
}
func squares1(c chan int) {
	for i := 0; i <= 4; i++ {
		num := <-c
		fmt.Println(num * num)
	}
}
func sender(c chan int) {
	c <- 1   // len 1, cap 3
	c <- 2   // len 2, cap 3
	c <- 3   // len 3, cap 3
	c <- 4   // <- goroutine blocks here
	close(c) //  закрываем канал
}
func squares2(c chan int) {
	for i := 0; i <= 4; i++ {
		num := <-c
		fmt.Println(num * num)
	}
}
func square(c chan int) {
	fmt.Println("[square] reading")
	num := <-c
	c <- num * num
}
func cube(c chan int) {
	fmt.Println("[cube] reading")
	num := <-c
	c <- num * num * num
}
