// Горутины и конкурентность — Многопоточность в Go (https://golangify.com/goroutines)
// В Go независимо запущенная задача называется горутиной.
// Горутины позволяют запускать любое количество действий одновременно.
package main

import (
	"fmt"
	"math/rand"
	"strings"
	"time"
)

func main() { // Функция main, сама по себе, является горутиной.
	// Запуск горутины в Golang
	// Запустить горутину так же просто, как и вызвать функцию. Вам нужно поставить ключевое слово go перед вызовом.
	go sleepyGopher() // начало горутины
	for i := 0; i < 4; i++ {
		time.Sleep(1 * time.Second) // ожидание храпа гофера
		fmt.Println(i)
	}
	// Т.е., что произошло: пока выполнялась функция sleepyGopher, функция Sleep из пакета time тоже начала отсчёт времени. Если убрать ключевое слово go, то отсчёт будет вестись после выполнения функции sleepyGopher

	fmt.Println("----------------------------------------------------------------------------------------------------------------")
	// Создание нескольких горутин в Golang
	// Функция main в Листинге 2 начинается с пятью горутинами sleepyGopher. Все они спят по три секунды, а затем выводят на экран одно и то же:
	for i := 0; i < 5; i++ {
		go sleepyGopher()
	}
	time.Sleep(4 * time.Second)
	// При запуске следующего листинга вы увидите, что хотя мы запустили все горутины по очереди от нуля до девяти, они все завершились в разное время.
	for i := 0; i < 5; i++ {
		go sleepyGopher_2(i)
	}
	time.Sleep(4 * time.Second)

	fmt.Println("----------------------------------------------------------------------------------------------------------------")
	// Каналы общения между горутинами в Golang
	// Для создания канала используется встроенная функция make, та же самая, что используется для создания карт и срезов.
	// У каналов есть тип, что уточняется во время их создания. Следующий канал может отправлять и принимать только целочисленные integer значения:
	// c := make(chan int)
	// Отправлять и получать значения канал может через оператор левой стрелки (<-).
	// Следующий код посылает значение 99:
	// c <- 99
	// В следующем коде мы получаем значение из канала c и сохраняем это значение в переменную r:
	// r := <-c
	// Код в Листинге 4 создает канал и передает его пяти спящим горутинам.
	// Затем он ждет получения пяти сообщений, одним из которых является начатая горутина.
	// Каждая горутина спит и затем отправляет значения, тем самым идентифицируя себя.
	c := make(chan int) // Делает канал для связи (или просто создаём канал)
	for i := 0; i < 5; i++ {
		go sleepyGopher_3(i, c)
	}
	for i := 0; i < 5; i++ {
		gopherID := <-c // Получает значение от канала
		fmt.Println("gopher ", gopherID, " has finished sleeping")
	}

	fmt.Println("----------------------------------------------------------------------------------------------------------------")
	// Использование select в канале горутин
	// В следующем листинге используется time.After для создания канала тайм-аута, а затем используется select для ожидания каналом сонных гоферов и тайм-аута канала.
	// Код закоментирован, т.к. после выполнения выходит из программы (из-за присутствия time.After)
	// timeout := time.After(2 * time.Second)
	// for i := 0; i < 5; i++ {
	// 	select { // Оператор select выглядит как оператор switch.
	// 	case gopherID := <-c: // ждет, когда проснется гофер
	// 		fmt.Println("gopher ", gopherID, " has finished sleeping")
	// 	case <-timeout: // ждет окончания времени
	// 		fmt.Println("my patience ran out")
	// 		return // сдается и возвращается
	// 	}
	// }
	// Гоферы в следующем листинге спят случайное количество времени. При запуске вы увидите, что некоторые гоферы просыпаются вовремя, а некоторые нет.
	for i := 0; i < 5; i++ {
		go sleepyGopher_4(i, c)
		gopherID := <-c // в обязательном порядке значение должно быть возвращено
		fmt.Println(gopherID)
	}

	fmt.Println("----------------------------------------------------------------------------------------------------------------")
	// Каналы nil в Golang ничего не делают
	// nil является нулевым значением канала по умолчанию.
	// Если вы попробуете использовать канал nil, он не вызовет сбой — вместо этого операция (отправки или приема) заблокируется навечно, как канал, что никогда ничего не отправляет или не получает.
	// Исключением является close, который подробнее будет описан далее. Если вы попытаетесь закрыть канал nil, произойдет сбой.

	fmt.Println("----------------------------------------------------------------------------------------------------------------")
	// Блокировка и deadlock в Golang
	// Когда одна или несколько горутин блокируются из-за того, что никогда не произойдет, это называется тупиком или deadlock.
	// Программа будет зависать или сбиваться. Deadlock может быть  вызван чем-то простым:
	// c_2 := make(chan int)
	// <- c_2

	fmt.Println("----------------------------------------------------------------------------------------------------------------")
	// Объединение горутин в конвейер
	// Создадим объединение работников, что обрабатывают строки.
	// Нам не нужно начинать новую горутину за последнего гофера, потому что мы хотим подождать его выполнения перед выходом из целой программы.
	// Если у последнего гофера все же запустить горутину, то программа завершится сразу после запуска, так как это конец программы.
	// Горутины просто не успеют отработать.
	c0 := make(chan string)
	c1 := make(chan string)
	// i0 := make(chan int)
	// i1 := make(chan int)
	// go sourceGopher(c0, i0)
	// go filterGopher(c0, c1, i0, i1)
	// printGopher(c1, i1)
	go sourceGopher(c0)
	go filterGopher(c0, c1)
	printGopher(c1)

} // здесь все горутины останавливаются
func sleepyGopher() {
	for i := 0; i < 3; i++ {
		time.Sleep(1 * time.Second) // гофер спит
		fmt.Println(i)
	}
	fmt.Println("...snore...")
}
func sleepyGopher_2(id int) {
	time.Sleep(3 * time.Second)
	fmt.Println("... ", id, " snore...")
}
func sleepyGopher_3(id int, c chan int) { // Объявляет канал как аргумент
	time.Sleep(3 * time.Second)
	fmt.Println("... ", id, " snore ...")
	c <- id // Отправляет значение обратно к main
}
func sleepyGopher_4(id int, c chan int) {
	time.Sleep(time.Duration(rand.Intn(4000)) * time.Millisecond) // режим ожидания (спящий режим) рандомное количество времени
	fmt.Println("... ", id, " snore ...")
	c <- id // Отправляет значение обратно к main
}

// Гофер в начале ряда объединения показан в Листинге 7 — источник потока. Данный гофер не читает значения, он только отправляет их.
// Внимание! порядок обработки string-выражений в срезе упорядочен.
func sourceGopher(downstream chan string) {
	for _, v := range []string{"hello world", "a bad apple", "goodbye all", "morning sun", "next over space", "a bad cat", "dog is mine", "reading copybook"} {
		downstream <- v
		// iddown <- i
	}
	close(downstream) // Go позволяет закрыть канал через close для обозначения, что значения больше не будут отправляться.
}

/*
// Гофер из Листинга 8 отфильтровывает все плохое из потока. Он читает элемент из верхнего канала и посылает его в канал нижнего потока только тога, когда в значении нет строки "bad".
// Когда он видит пустую строку, то гофер-фильтр завершает свою работу, отправив пустую строку следующему гоферу вниз по линии
	func filterGopher(upstream, downstream chan string){
	for {
		item, ok := <- upstream
		// id := <- idup
		if !ok {
			close(downstream)	// закрываем поток
			return
		}
		if !strings.Contains(item, "bad"){
			downstream <- item
			// iddown <- id
		}
	}
}
*/
// Сокращенный вариант.
// Если мы используем канал в операторе range, он будет читать значения из канала, пока тот не будет закрыт.
// Это значит, что код можно переписать проще с циклом range. Следующий код делает то же самое, что и предыдущий.
func filterGopher(upstream, downstream chan string) {
	for item := range upstream {
		if !strings.Contains(item, "bad") {
			downstream <- item
		}
	}
	close(downstream)
}

/*
// Гофер, что находится в конце конвейера — гофер вывода — показан в Листинге 9.
// Здесь гофер-вывода показывает все увиденные значения.
	func printGopher(upstream chan string){
	for {
		v := <- upstream
		// n := <- idup
		if v == "" {
			return
		}
		// fmt.Printf("%v %v\n",n , v)
		fmt.Println(v)
	}
}
*/
// Сокращенный вариант.
func printGopher(upstream chan string) {
	for v := range upstream {
		fmt.Println(v)
	}
}
